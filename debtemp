#!/usr/bin/env bash

set -eu

# shellcheck disable=SC2034
VERSION="0.0.1"
SCRIPT_NAME=$(basename "$0")
REPO_VERSION=""
REPO_USER=""
REPO_NAME=""
USER_NAME=""
USER_EMAIL=""
ARCHITECTURE="all"
DEB_NAME=""
DEBTEMP_DIR="$HOME/.cache/debtemp"
PKG_DIR="$DEBTEMP_DIR/pkg"
DEB_DIR="$DEBTEMP_DIR/deb"

# if $1 not there exit
if [ $# -eq 0 ]; then
    echo "No arguments provided"
    exit 1
else
    # check a slash in shinokada/repo-name
    slash_num=$(echo "$1" | grep -o "/" | wc -l)
    if [ ! "$slash_num" -eq 1 ]; then
        echo "Use username/repo"
        exit
    fi
fi

readlinkf() {
    [ "${1:-}" ] || return 1
    max_symlinks=40
    CDPATH='' # to avoid changing to an unexpected directory

    target=$1
    [ -e "${target%/}" ] || target=${1%"${1##*[!/]}"} # trim trailing slashes
    [ -d "${target:-/}" ] && target="$target/"

    cd -P . 2>/dev/null || return 1
    while [ "$max_symlinks" -ge 0 ] && max_symlinks=$((max_symlinks - 1)); do
        if [ ! "$target" = "${target%/*}" ]; then
            case $target in
            /*) cd -P "${target%/*}/" 2>/dev/null || break ;;
            *) cd -P "./${target%/*}" 2>/dev/null || break ;;
            esac
            target=${target##*/}
        fi

        if [ ! -L "$target" ]; then
            target="${PWD%/}${target:+/}${target}"
            printf '%s\n' "${target:-/}"
            return 0
        fi
        link=$(ls -dl -- "$target" 2>/dev/null) || break
        target=${link#*" $target -> "}
    done
    return 1
}

self=$(readlinkf "$0")
script_dir=${self%/*}

# shellcheck disable=SC1091
{
    . "${script_dir}/lib/getoptions.sh"
    . "${script_dir}/lib/utils.sh"
}

# shellcheck disable=SC1083
parser_definition() {
    setup REST help:usage abbr:true -- \
        "Usage: ${2##*/} [command] [options...] [arguments...]"
    msg -- '' 'Options:'
    disp :usage -h --help
    disp VERSION --version

    msg -- '' 'Commands: '
    msg -- 'Use command -h for a command help.'
    # cmd 3d -- "3D letters style texts."

    msg -- '' "Examples:


Display the version:
    $SCRIPT_NAME --version
Display help:
    $SCRIPT_NAME -h | --help
"
}

eval "$(getoptions parser_definition parse "$0") exit 1"
parse "$@"
eval "set -- $REST"

# check DEBTEMP_DIR if not create it
if [ ! -d "$DEBTEMP_DIR" ]; then
    mkdir -p "$DEBTEMP_DIR" || {
        echo "Not able to create a dir."
        exit 1
    }
else
    # remove all files in ${DEBTEMP_DIR}
    rm -rf "${DEBTEMP_DIR:?}/"* || {
        echo "Not able to clean the cache dir."
        exit 1
    }
    echo "files in cache dir are removed."
fi

# create PKG_DIR and DEB_DIR
mkdir -p "$PKG_DIR" "$DEB_DIR" || {
    echo "Not able to create dirs"
    exit 1
}

# get REPO_NAME and USER from $1
REPO_USER=$(first "/" "$1")
REPO_NAME=$(second "/" "$1")
echo "$REPO_USER"
echo "$REPO_NAME"

# get Full name and email from git log --list
UNAME=$(git config --list | grep user.name)
USER_NAME=$(second "=" "$UNAME")
UEMAIL=$(git config --list | grep user.email)
USER_EMAIL=$(second "=" "$UEMAIL")

# get the version from curl
HTML=$(curl -sH "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/${REPO_USER}/${REPO_NAME}/releases/latest" | grep "tarball_url")

string="${HTML##*/v}"
string1="${string//\"/}"

REPO_VERSION="${string1//,/}"
echo "$REPO_VERSION"

# read (to confirm)
read -r -e -i "$REPO_NAME" -p "Please enter your repo name: " input
REPO_NAME="${input:-$REPO_NAME}"

read -r -e -i "$REPO_VERSION" -p "Please enter your repo version: " input
REPO_VERSION="${input:-$REPO_VERSION}"

REVISION_NUM=1
read -r -e -i "$REVISION_NUM" -p "Please enter your revision number: " input
REVISION_NUM="${input:-$REVISION_NUM}"

read -r -e -i "$ARCHITECTURE" -p "Please enter your architecture: " input
ARCHITECTURE="${input:-$ARCHITECTURE}"

# PACKAGE_NAME_VersionNumber-RevisionNumber_DebianArchitecture
DEB_NAME="${REPO_NAME}_${REPO_VERSION}-${REVISION_NUM}_${ARCHITECTURE}"

# create dirs PKG_DIR/${DEB_NAME}/DEBIAN, PKG_DIR/${DEB_NAME}/usr/bin, PKG_DIR/${DEB_NAME}/usr/share/$1 where $1 is the first parameter in pkg_code
mkdir -p "$PKG_DIR/$DEB_NAME/DEBIAN" "$PKG_DIR/$DEB_NAME/usr/bin" "$PKG_DIR/$DEB_NAME/usr/share/$REPO_NAME"

# create/copy files to PKG_DIR/${DEB_NAME}/DEBIAN/control, PKG_DIR/${DEB_NAME}/DEBIAN/preinst

cat <<EOF >"$PKG_DIR/$DEB_NAME/DEBIAN/CONTROL"
Package: ${REPO_NAME}
Version: ${REPO_VERSION}
Architecture: ${ARCHITECTURE}
Maintainer: ${USER_NAME}<${USER_EMAIL}>
Depends:
Homepage: https://github.com/${REPO_USER}/${REPO_NAME}
Description:
EOF

cat <<EOF >"$PKG_DIR/$DEB_NAME/DEBIAN/preinst"
#!/bin/bash
# This removes an old version.

echo "Looking for old versions of ${REPO_NAME} ..."

if [ -f "/usr/bin/${REPO_NAME}" ]; then
    sudo rm -f /usr/bin/${REPO_NAME}
    echo "Removed the old ${REPO_NAME} from /usr/bin ..."
fi

if [ -d "/usr/share/${REPO_NAME}" ]; then
    sudo rm -rf /usr/share/${REPO_NAME}
    echo "Removed the old ${REPO_NAME} from /usr/share ..."
fi
EOF

# clone the repo to "$PKG_DIR/$DEB_NAME/usr/share/$REPO_NAME"
TARGET_DIR="$PKG_DIR/$DEB_NAME/usr/share/$REPO_NAME"
git clone --quiet git@github.com:"${REPO_USER}/${REPO_NAME}".git "$TARGET_DIR" || exit

# Move the main script to usr/bin/${REPO_NAME}
mv "$TARGET_DIR/${REPO_NAME}" "$PKG_DIR/$DEB_NAME/usr/bin"

# change the permission
sudo chown root:root -R "$PKG_DIR/$DEB_NAME"
sudo chmod 755 "$PKG_DIR/$DEB_NAME/usr/bin/$REPO_NAME"
sudo chmod 755 "$PKG_DIR/$DEB_NAME/DEBIAN/preinst"

# generate deb package
cd "$PKG_DIR" && dpkg-deb --build "$DEB_DIR/$DEB_NAME" || {
    echo "Not able to create a debian package."
    exit
}

echo "Done!"
